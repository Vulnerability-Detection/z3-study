{"./":{"url":"./","title":"Introduction","keywords":"","body":"z3-study z3学习（推荐使用Python进行学习。） z3是由微软公司开发的一个优秀的SMT求解器（其实就是一个定理证明器），它能够检查逻辑表达式的可满足性。 from z3 import * if __name__ == '__main__': solver = Solver() # 第1步：创建求解器 x = Int('x') y = Int('y') solver.add(x > 2) solver.add(y 学习资源 [x] z3 github：https://github.com/Z3Prover/z3 [ ] API文档（C、C++、.NET、Java、Python）：http://z3prover.github.io/api/html/index.html 【Python】http://z3prover.github.io/api/html/namespacez3py.html 【官方教程】Getting Started with Z3: A Guide： http://rise4fun.com/z3/tutorial/guide https://rise4fun.com/Z3/tutorialcontent/fixedpoints https://rise4fun.com/Z3/tutorial/strategies [x] 【Python】z3 API in Python：https://ericpony.github.io/z3py-tutorial/guide-examples.htm Z3py tutorial：https://github.com/ericpony/z3py-tutorial 103 【翻译】Z3 API in PYTHON 中文文档 （官方文档翻译）：https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/ 【翻译】Z3 API in Python：https://nen9ma0.github.io/2018/03/14/z3py/ [ ] SMT竞赛：https://smt-comp.github.io/2021/ SAT竞赛：http://www.satcompetition.org/ [ ] SMT-LIB：http://smtlib.cs.uiowa.edu/ [ ] 二进制分析框架angr框架的内置Z3：https://github.com/angr/angr-z3 [ ] Go Bindings to the Z3 Theorem Prover：https://github.com/mitchellh/go-z3 [ ] Leonardo de Moura（Senior Principal Researcher）：https://www.microsoft.com/en-us/research/people/leonardo/publications/ 其它求解器 http://smtlib.cs.uiowa.edu/solvers.shtml Yices CVC3 Simplify TSAT MathSAT Verifun Ario 相关关键概念/Keyword SAT（Satisfiability）：指命题逻辑公式的可满足性问题。 SMT（Satisfiability Modulo Theories）：被翻译为“可满足性模理论”、“多理论下的可满足性问题”或者“特定（背景）理论下的可满足性问题”，其判定算法被称为SMT求解器。 SMT算法分为2种：积极（eager）类算法/惰性（lazy）类算法（主流）。 CNF（conjunctive normal form）：命题公式的合取范式形式。也就是形如A1^A2^...^An的公式，其中每一个Ai是一个子句。 UF（uninterpreted function）：未解释函数。 LRA（linear real arithmetic）：线性实数演算。 LIA（linear integer arithmetic）：线性整数演算。 NRA（non-linear real arithmetic）：非线性实数演算。 NIA（non-linear integer arithmetic）：非线性整数演算。 RDL（difference logic over the reals）：实数差分逻辑。 IDL（difference logic over the integers）：整数差分逻辑。 arrays：数组。 BV（bit vector）：位向量。 DPLL算法 （Davis-Putnam-Logemann-Loveland algorithm）。 CDCL算法（conflict-driven clause learning SAT solver)：基于冲突检测的子句学习求解算法。 DAG（directed acyclic graph）：有向无环图。 教程-视频 [x] Z3入门简介：https://www.bilibili.com/s/video/BV1T7411C7tG 教程/文章/安装参考 [x] win10：带你入逆向坑，怎样在win10上安装并使用Z3库：https://www.jianshu.com/p/5530c6bb4a39 [x] z3-solver安装和使用方法：https://www.cnblogs.com/pcat/p/12592272.html [x] [python/工具] python z3库学习 减乘除位与运算 ctf一把梭：https://www.jianshu.com/p/64d87659673a [ ] Z3求解器简介及环境搭建：https://blog.csdn.net/guo_shaokun/article/details/99891545 [ ] Intro to Binary Analysis with Z3 and angr：https://github.com/FSecureLABS/z3_and_angr_binary_analysis_workshop [ ] z3-playground：https://github.com/0vercl0k/z3-playground 218 经典应用 约束求解 八皇后 数独 安装依赖、冲突问题 CTF竞赛解题 [x] 使用Z3 Solver求解逻辑题：https://www.7forz.com/3255/ [ ] Z3简介及在逆向领域的应用：https://cloud.tencent.com/developer/article/1423409 Paper [x] 【综述】金继伟,马菲菲,张健.SMT求解技术简述[J].计算机科学与探索,2015,9(07):769-780. http://fcst.ceaj.org/CN/abstract/abstract956.shtml [x] 【综述】王翀,吕荫润,陈力,王秀利,王永吉.SMT求解技术的发展及最新应用研究综述[J].计算机研究与发展,2017,54(07):1405-1425. https://crad.ict.ac.cn/CN/10.7544/issn1000-1239.2017.20160303 [ ] Programming Z3：https://theory.stanford.edu/~nikolaj/programmingz3.html [ ] 【cite:7158】Z3: An Efficient SMT Solver：https://link.springer.com/content/pdf/10.1007%2F978-3-540-78800-3_24.pdf [ ] yinyang: a fuzzer for SMT solvers：https://github.com/testsmt/yinyang 84 [ ] 【PLDI2020 CCF-A】Validating SMT solvers via semantic fusion：http://chengyuzhang.com/ [ ] On the unusual effectiveness of type-aware operator mutations for testing SMT solvers [ ] 【ASE2019 CCF-A】Manticore: A User-Friendly Symbolic Execution Framework for Binaries and Smart Contracts：https://github.com/trailofbits/manticore Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/install/install.html":{"url":"docs/install/install.html","title":"安装","keywords":"","body":"Linux安装教程 git clone https://github.com/Z3Prover/z3.git cd z3 python scripts/mk_make.py cd build make make install window10安装z3-solver python版本 注意pip安装的是z3-solver，而不是z3。 步骤 方法1：使用pip安装z3（错误） # 安装 pip install z3 # 测试 z3 -h usage: z3 [-h] [--s3-prefix S3_PREFIX] [--filesystem FILESYSTEM] [--snapshot-prefix SNAPSHOT_PREFIX] {backup,restore,status} ... list z3 snapshots positional arguments: {backup,restore,status} sub-command help backup backup local zfs snapshots to an s3 bucket restore not implemented status show status of current backups optional arguments: -h, --help show this help message and exit --s3-prefix S3_PREFIX S3 key prefix, defaults to z3-backup/ --filesystem FILESYSTEM, --dataset FILESYSTEM the zfs dataset/filesystem to operate on --snapshot-prefix SNAPSHOT_PREFIX Only operate on snapshots that start with this prefix. Defaults to zfs-auto-snap:daily. 方法1：使用pip安装z3-solver（正确） pip install z3-solver 测试-python文件运行 输入xx.python # 示例1 from z3 import * if __name__ == \"__main__\": x, y, z = Ints('x y z') s = Solver() s.add(2 * x + 3 * y + z == 6) s.add(x - y + 2 * z == -1) s.add(x + 2 * y - z == 5) # 解方程=> x = 2, y = 1, z = -1 # 2x + 3y + z = 6 # x - y + 2z = -1 # x + 2y - z = 5 print(s.check()) # sat print(s.model()) # [z = -1, y = 1, x = 2] 输出 sat [z = -1, y = 1, x = 2] 输入：xx.python # 示例2 from z3 import * if __name__ == \"__main__\": x = Int('x') s = Solver() a = 65537 b = 64834 c = 41958 s.add(x > 0) s.add(x % a == b) s.add(x % b == c) print(s.check()) # sat print(s.model()) # [x = 227609298] 输出 sat [x = 227609298] python安装 安装 1、pip install指定版本 https://pypi.org/project/z3-solver/4.8.10.0/#files pip install z3-solver==4.8.10.0 Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"empty.html":{"url":"empty.html","title":"教程","keywords":"","body":"Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/tutorial/2-Z3API_in_Python-Advanced.html":{"url":"docs/tutorial/2-Z3API_in_Python-Advanced.html","title":"2-Python中的z3 api-Advanced","keywords":"","body":"Python中的z3 api-Advanced 源地址：https://ericpony.github.io/z3py-tutorial/advanced-examples.htm 1、进阶主题 请向leonardo@microsoft.com发送反馈，评论和/或更正。 您的评论非常有价值。 2、表达式，排序和声明 在Z3中，表达式，排序和声明称为AST。 AST是有向无环图。 每个表达式都有一个排序（aka类型）。 方法sort（）检索表达式的排序。 # 示例63 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Real('y') print((x + 1).sort()) # Int print((y + 1).sort()) # Real print((x >= 2).sort()) # Bool 如果n1和n2是相同的AST，则函数eq（n1，n2）返回True。 这是一个结构测试。 # 示例64 from z3 import * if __name__ == \"__main__\": x, y = Ints('x y') print(eq(x + y, x + y)) # True print(eq(x + y, y + x)) # False n = x + y print(eq(n, x + y)) # True # x2 is eq to x x2 = Int('x') print(eq(x, x2)) # True # the integer variable x is not equal to # the real variable x print(eq(Int('x'), Real('x'))) # False 方法hash（）返回AST节点的哈希码。 如果eq（n1，n2）返回True，则n1.hash（）等于n2.hash（）。 # 示例65 from z3 import * if __name__ == \"__main__\": x = Int('x') print((x + 1).hash()) # 1880882057 print((1 + x).hash()) # 3655631788 print(eq(x + 1, 1 + x)) # False print(x.sort().hash()) # 2867189042 Z3表达式可分为三个基本组：应用程序，量词和有界/自由变量。 如果您的问题不包含通用/现有量词，则只需要应用程序。 尽管我们说Int（'x'）是一个整数“变量”，但从技术上讲它是一个整数常数，并且内部表示为具有0个参数的函数应用程序。 每个应用程序都与一个声明关联，并包含0个或多个参数。 方法decl（）返回与应用程序关联的声明。 方法num_args（）返回应用程序的参数数量，并返回arg（i）参数之一。 如果n是一个表达式，则函数is_expr（n）返回True。 同样，如果n是应用程序（声明），则is_app（n）（is_func_decl（n））返回True。 # 示例66 from z3 import * if __name__ == \"__main__\": x = Int('x') print(\"is expression: \", is_expr(x)) # is expression: True n = x + 1 print(\"is application:\", is_app(n)) # is application: True print(\"decl: \", n.decl()) # decl: + print(\"num args: \", n.num_args()) # num args: 2 for i in range(n.num_args()): print(\"arg(\", i, \") ->\", n.arg(i)) # arg( 0 ) -> x # arg(1) -> 1 声明有名称，可以使用name（）方法检索它们。 （函数）声明具有Arity，域和范围排序。 # 示例67 from z3 import * if __name__ == \"__main__\": x = Int('x') x_d = x.decl() print(\"is_expr(x_d): \", is_expr(x_d)) # is_expr(x_d): False print(\"is_func_decl(x_d):\", is_func_decl(x_d)) # is_func_decl(x_d): True print(\"x_d.name(): \", x_d.name()) # x_d.name(): x print(\"x_d.range(): \", x_d.range()) # x_d.range(): Int print(\"x_d.arity(): \", x_d.arity()) # x_d.arity(): 0 # x_d() creates an application with 0 arguments using x_d. # x_d（）使用x_d创建带有0个参数的应用程序。 print(\"eq(x_d(), x): \", eq(x_d(), x)) # eq(x_d(), x): True print(\"\\n\") # f is a function from (Int, Real) to Bool # f是从（Int，Real）到Bool的函数 f = Function('f', IntSort(), RealSort(), BoolSort()) print(\"f.name(): \", f.name()) # f.name(): f print(\"f.range(): \", f.range()) # f.range(): Bool print(\"f.arity(): \", f.arity()) # f.arity(): 2 for i in range(f.arity()): print(\"domain(\", i, \"): \", f.domain(i)) # f(x, x) creates an application with 2 arguments using f. # f（x，x）使用f创建带有2个参数的应用程序。 print(f(x, x)) # f(x, ToReal(x)) print(eq(f(x, x).decl(), f)) # True 内置声明使用其种类进行标识。 使用方法kind（）检索种类。 内置声明的完整列表可以在Z3发行版的文件z3consts.py（z3_api.h）中找到。 # 示例68 from z3 import * if __name__ == \"__main__\": x, y = Ints('x y') print((x + y).decl().kind()) # 518 print((x + y).decl().kind() == Z3_OP_ADD) # True print((x + y).decl().kind() == Z3_OP_SUB) # False 下面的示例演示如何在Z3表达式中替换子表达式。 # 示例69 from z3 import * if __name__ == \"__main__\": x, y = Ints('x y') f = Function('f', IntSort(), IntSort(), IntSort()) g = Function('g', IntSort(), IntSort()) n = f(f(g(x), g(g(x))), g(g(y))) print(n) # f(f(g(x), g(g(x))), g(g(y))) # substitute g(g(x)) with y and g(y) with x + 1 # 用y替换g（g（x））并用x + 1替换g（y） print(substitute(n, (g(g(x)), y), (g(y), x + 1))) # f(f(g(x), y), g(x + 1)) 函数Const（name，sort）声明给定排序的常量（即变量）。 例如，函数Int（name）和Real（name）是Const（name，IntSort（））和Const（name，RealSort（））的简写。 # 示例70 from z3 import * if __name__ == \"__main__\": x = Const('x', IntSort()) print(eq(x, Int('x'))) # True a, b = Consts('a b', BoolSort()) print(And(a, b)) # And(a, b) 3、数组 作为制定数学计算理论程序的一部分，McCarthy提出了一种以选择存储公理为特征的阵列基本理论。 表达式Select（a，i）返回存储在数组a的位置i处的值； 然后Store（a，i，v）返回一个与a相同的新数组，但是在位置i上包含值v。 在Z3Py中，我们还可以将Select（a，i）编写为a [i]。 # 示例71 from z3 import * if __name__ == \"__main__\": # Use I as an alias for IntSort() # 使用I作为IntSort（）的别名 I = IntSort() # A is an array from integer to integer # A是一个从整数到整数的数组 A = Array('A', I, I) x = Int('x') print(A[x]) # A[x] print(Select(A, x)) # A[x] print(Store(A, x, 10)) # Store(A, x, 10) print(simplify(Select(Store(A, 2, x + 1), 2))) # 1 + x 默认情况下，Z3假定数组在select之上是可扩展的。 换句话说，Z3还强制要求，如果两个数组在所有位置上都一致，则数组相等。 Z3还包含对阵列操作的各种扩展，这些扩展仍可确定并适用于有效的饱和过程 （此处为有效手段，具有NP完全可满足性的复杂性）。 我们在下面使用示例集合来描述这些扩展。 有关这些扩展的其他背景信息， 请参见通用和高效阵列决策程序。 Z3中的数组用于建模无边界或非常大的数组。 数组不应用于对值的有限有限集合进行建模。 使用列表推导创建不同的变量通常会更有效。 # 示例72 from z3 import * if __name__ == \"__main__\": # We want an array with 3 elements. # 1. Bad solution X = Array('x', IntSort(), IntSort()) # Example using the array print(X[0] + X[1] + X[2] >= 0) # x[0] + x[1] + x[2] >= 0 # 2. More efficient solution X = IntVector('x', 3) print(X[0] + X[1] + X[2] >= 0) # x__0 + x__1 + x__2 >= 0 print(Sum(X) >= 0) # x__0 + x__1 + x__2 >= 0 1、Select and Store 让我们首先检查数组的基本属性。 假设A是一个整数数组，则约束A [x] == x，Store（A，x，y）== A对于包含映射到x的索引x的数组是可满足的，并且当x == y。 我们可以解决这些约束。 # 示例73 from z3 import * if __name__ == \"__main__\": A = Array('A', IntSort(), IntSort()) x, y = Ints('x y') solve(A[x] == x, Store(A, x, y) == A) # [A = Store(K(Int, 2), 0, 0), y = 0, x = 0] 数组变量的解释/解决方案与用于函数的解释/解决方案非常相似。 如果添加约束x！= y，问题将变得无法解决/无法实现。 # 示例74 from z3 import * if __name__ == \"__main__\": A = Array('A', IntSort(), IntSort()) x, y = Ints('x y') solve(A[x] == x, Store(A, x, y) == A, x != y) # no solution 2、常量数组 可以使用K（s，v）构造在Z3Py中指定将所有索引映射到某个固定值的数组，其中s是排序/类型，v是表达式。 K（s，v）返回一个数组，该数组将s的任何值映射到v。 下面的示例定义一个仅包含1的常量数组。 # 示例75 from z3 import * if __name__ == \"__main__\": AllOne = K(IntSort(), 1) a, i = Ints('a i') solve(a == AllOne[i]) # [a = 1] # The following constraints do not have a solution # 以下约束没有解决方案 solve(a == AllOne[i], a != 1) # no solution 4、Datatypes 从诸如ML之类的编程语言中已知的代数数据类型为指定通用数据结构提供了一种方便的方法。 记录和元组是代数数据类型的特例，标量（枚举类型）也是如此。 但是代数数据类型更为通用。它们可用于指定有限列表，树和其他递归结构。 下面的示例演示如何在Z3Py中声明列表。它比使用SMT 2.0前端更为冗长，但比使用Z3 C API简单得多。 它包括两个阶段。首先，我们必须声明新的数据类型，其构造函数和访问器。 函数Datatype（'List'）声明一个“占位符”，它将包含构造函数和访问器声明。 方法clarify（cname，（aname，sort）+）声明一个具有给定访问器的名为cname的构造函数。 每个访问器都有一个关联的排序或对要声明的数据类型的引用。 例如，clarify（'cons'，（'car'，IntSort（）），（'cdr'，List））声明名为cons的构造函数，该构造函数使用整数和List来构建新的List。 它还声明了accessor car和cdr。访问车提取cons单元的整数，并cdr cons单元的列表。 声明所有构造函数后，我们使用create（）方法在Z3中创建实际的数据类型。 Z3Py使新的Z3声明和常量可用作新对象的插槽。 # 示例76 from z3 import * if __name__ == \"__main__\": # Declare a List of integers # 声明一个整数列表 List = Datatype('List') # Constructor cons: (Int, List) -> List # 构造方法：（Int，List）-> List List.declare('cons', ('car', IntSort()), ('cdr', List)) # Constructor nil: List # 构造函数nil：列表 List.declare('nil') # Create the datatype # 创建数据类型 List = List.create() print(is_sort(List)) # True print() cons = List.cons car = List.car cdr = List.cdr nil = List.nil # cons, car and cdr are function declarations, and nil a constant print(is_func_decl(cons)) # True print(is_expr(nil)) # True l1 = cons(10, cons(20, nil)) print(l1) # cons(10, cons(20, nil)) print(simplify(cdr(l1))) # cons(20, nil) print(simplify(car(l1))) # 10 print(simplify(l1 == nil)) # False 以下示例演示如何定义给定排序的Python函数创建给定排序的列表。 # 示例77 from z3 import * if __name__ == \"__main__\": def DeclareList(sort): List = Datatype('List_of_%s' % sort.name()) List.declare('cons', ('car', sort), ('cdr', List)) List.declare('nil') return List.create() IntList = DeclareList(IntSort()) RealList = DeclareList(RealSort()) IntListList = DeclareList(IntList) l1 = IntList.cons(10, IntList.nil) print(l1) # cons(10, nil) print(IntListList.cons(l1, IntListList.cons(l1, IntListList.nil))) # cons(cons(10, nil), cons(cons(10, nil), nil)) print(RealList.cons(\"1/3\", RealList.nil)) # cons(1/3, nil) print(l1.sort()) # List_of_Int 上面的示例演示Z3支持运算符重载。 有几个名为cons的函数，但是它们不同，因为它们接收和/或返回不同种类的值。 请注意，不必为排序列表的每个实例使用不同的排序名称。 也就是说，表达式'Listof％s'％sort.name（）是不必要的，我们仅使用它来提供更有意义的名称。 如上所述，枚举类型是代数数据类型的特殊情况。 下面的示例声明一个枚举类型，该枚举类型由三个值组成：红色，绿色和蓝色。 # 示例78 from z3 import * if __name__ == \"__main__\": Color = Datatype('Color') Color.declare('red') Color.declare('green') Color.declare('blue') Color = Color.create() print(is_expr(Color.green)) # True print(Color.green == Color.blue) # green == blue print(simplify(Color.green == Color.blue)) # False # Let c be a constant of sort Color # 令c为排序常数Color c = Const('c', Color) # Then, c must be red, green or blue # 然后，c必须是红色，绿色或蓝色 prove(Or(c == Color.green, c == Color.blue, c == Color.red)) # proved Z3Py还提供了以下快捷方式来声明枚举排序。 # 示例79 from z3 import * if __name__ == \"__main__\": Color, (red, green, blue) = EnumSort('Color', ('red', 'green', 'blue')) print(green == blue) # green == blue print(simplify(green == blue)) # False c = Const('c', Color) solve(c != green, c != blue) # [c = red] 也可以声明相互递归的数据类型。 唯一的区别是我们使用函数CreateDatatypes而不是方法create（）来创建相互递归的数据类型。 # 示例80 from z3 import * if __name__ == \"__main__\": TreeList = Datatype('TreeList') Tree = Datatype('Tree') Tree.declare('leaf', ('val', IntSort())) Tree.declare('node', ('left', TreeList), ('right', TreeList)) TreeList.declare('nil') TreeList.declare('cons', ('car', Tree), ('cdr', TreeList)) Tree, TreeList = CreateDatatypes(Tree, TreeList) t1 = Tree.leaf(10) tl1 = TreeList.cons(t1, TreeList.nil) t2 = Tree.node(tl1, TreeList.nil) print(t2) # node(cons(leaf(10), nil), nil) print(simplify(Tree.val(t1))) # 10 t1, t2, t3 = Consts('t1 t2 t3', TreeList) solve(Distinct(t1, t2, t3)) # [t2 = cons(leaf(1), nil), t1 = nil, t3 = cons(leaf(2), nil)] 5、未解释的排序（Uninterpreted Sorts） 纯一阶逻辑中的功能和常数符号未解释或自由表示，这意味着没有附加先验解释。 这与算术运算符（例如+和-）具有固定的标准解释相反。 未解释的函数和常量具有最大的灵活性； 它们允许进行任何与函数或常量约束一致的解释。 为了说明未解释的函数和常量，让我们引入一个（未解释的）排序A，常量x，y遍及A。 最后，使f为一个未解释的函数，它接受一个A类型的参数，并得出A值。 该示例说明了如何强制解释，其中对x两次应用f会再次导致x，但是对x一次应用f与x不同。 # 示例81 from z3 import * if __name__ == \"__main__\": A = DeclareSort('A') x, y = Consts('x y', A) f = Function('f', A, A) s = Solver() s.add(f(f(x)) == x, f(x) == y, x != y) print(s.check()) # sat m = s.model() print(m) # [x = A!val!0, # y = A!val!1, # f = [A!val!1 -> A!val!0, else -> A!val!1]] print(\"interpretation assigned to A:\") print(m[A]) # [A!val!0, A!val!1] 最终的模型为A中的元素引入了抽象值，因为未解释排序A。 模型中对f的解释在x和y的两个值之间切换，这两个值是不同的。 表达式m [A]返回模型m中未解释的类别A的解释（Universe）。 6、量词 Z3可以解决包含算术，位向量，布尔值，数组，函数和数据类型在内的无量纲问题。 Z3还接受并可以使用使用量词的公式。 一般而言，它不再是此类公式的决策程序（并且由于充分的原因，因为一阶逻辑可能没有决策程序）。 # 示例82 from z3 import * if __name__ == \"__main__\": f = Function('f', IntSort(), IntSort(), IntSort()) x, y = Ints('x y') print(ForAll([x, y], f(x, y) == 0)) # ForAll([x, y], f(x, y) == 0) print(Exists(x, f(x, x) >= 0)) # Exists(x, f(x, x) >= 0) a, b = Ints('a b') solve(ForAll(x, f(x, x) == 0), f(a, b) == 1) # [b = 2, a = 0, f = [(0, 2) -> 1, else -> 0]] 尽管如此，Z3通常能够处理涉及量词的公式。 它使用多种方法来处理量词。 最丰富的方法是使用基于模式的量词实例化。 这种方法允许根据量词上的模式注释，使用出现在当前搜索上下文中的基本术语实例化量化公式。 Z3还包含一个基于模型的量词实例化组件，该组件使用模型构造来找到用于实例化量词的良好条件。 Z3还处理许多可确定的片段。 请注意，在前面的示例中，常数x和y用于创建量化公式。 这是简化Z3Py中量化公式的构造的“技巧”。 在内部，这些常量将替换为有界变量。下一个示例说明了这一点。 方法body（）检索量化的表达式。 在所得公式中，有界变量是自由的。 函数Var（index，sort）使用给定的index和sort创建一个有界/自由变量。 # 示例83 from z3 import * if __name__ == \"__main__\": f = Function('f', IntSort(), IntSort(), IntSort()) x, y = Ints('x y') f = ForAll([x, y], f(x, y) == 0) print(f.body()) # f(Var(1), Var(0)) == 0 v1 = f.body().arg(0).arg(0) # Var(1) print(v1) print(eq(v1, Var(1, IntSort()))) # True 1、用量词建模 假设我们要为具有单一继承的面向对象的类型系统建模。 我们将需要一个谓词来进行子类型输入。 子类型化应该是部分顺序，并尊重单一继承。 对于某些内置类型构造函数，例如array_of，子类型应该是单调的。 # 示例84 from z3 import * if __name__ == \"__main__\": Type = DeclareSort('Type') subtype = Function('subtype', Type, Type, BoolSort()) array_of = Function('array_of', Type, Type) root = Const('root', Type) x, y, z = Consts('x y z', Type) axioms = [ForAll(x, subtype(x, x)), ForAll([x, y, z], Implies(And(subtype(x, y), subtype(y, z)), subtype(x, z))), ForAll([x, y], Implies(And(subtype(x, y), subtype(y, x)), x == y)), ForAll([x, y, z], Implies(And(subtype(x, y), subtype(x, z)), Or(subtype(y, z), subtype(z, y)))), ForAll([x, y], Implies(subtype(x, y), subtype(array_of(x), array_of(y)))), ForAll(x, subtype(root, x))] s = Solver() s.add(axioms) # print(s) print() print(s.check()) # sat print(\"Interpretation for Type:\") print(s.model()[Type]) # [Type!val!1, Type!val!0] print(\"Model:\") print(s.model()) 2、模式 Stanford Pascal验证器和随后的Simplify定理证明器率先使用基于模式的量词实例化。 基于模式的量词实例化的基本思想在某种意义上是直截了当的：使用包含所有绑定变量的模式对量化公式进行注释。 因此，模式是一个表达式（不包含绑定操作，例如量词），它包含一个由量词绑定的变量。 然后，只要在搜索过程中创建了与模式匹配的术语，就实例化量词。 从概念上讲，这是一个简单的起点，但是有一些重要的微妙之处。 在以下示例中，前两个选项确保禁用基于模型的量词实例化引擎。 我们还用模式f（g（x））注释了量化公式。 由于没有该模式的基本实例，因此无法实例化量词，并且Z3无法显示该公式不满足要求。 # 示例85 from z3 import * if __name__ == \"__main__\": f = Function('f', IntSort(), IntSort()) g = Function('g', IntSort(), IntSort()) a, b, c = Ints('a b c') x = Int('x') s = Solver() s.set(auto_config=False, mbqi=False) s.add(ForAll(x, f(g(x)) == x, patterns=[f(g(x))]), g(a) == c, g(b) == c, a != b) # Display solver state using internal format # 使用内部格式显示求解器状态 print(s.sexpr()) # (declare - fun f (Int) Int) # (declare - fun g (Int) Int) # (declare - fun c () Int) # (declare - fun a () Int) # (declare - fun b () Int) # (assert (forall ((x Int)) (! (= (f (g x)) x):pattern((f(g x)))))) # (assert (= (g a) c)) # (assert (= (g b) c)) # (assert (distinct a b)) print(s.check()) # unknown 当使用更宽松的模式g（x）时。 Z3证明该公式不令人满意。 更具恢复性的模式将实例化的数量减至最少（并可能改善性能），但它们也可能使Z3“不那么完整”。 # 示例86 from z3 import * if __name__ == \"__main__\": f = Function('f', IntSort(), IntSort()) g = Function('g', IntSort(), IntSort()) a, b, c = Ints('a b c') x = Int('x') s = Solver() s.set(auto_config=False, mbqi=False) s.add(ForAll(x, f(g(x)) == x, patterns=[g(x)]), g(a) == c, g(b) == c, a != b) # Display solver state using internal format # 使用内部格式显示求解器状态 print(s.sexpr()) # (declare - fun g (Int) Int) # (declare - fun f (Int) Int) # (declare - fun c () Int) # (declare - fun a () Int) # (declare - fun b () Int) # (assert (forall ((x Int)) (! (= (f (g x)) x):pattern((g x))))) # (assert (= (g a) c)) # (assert (= (g b) c)) # (assert (distinct a b)) print(s.check()) # unsat 某些模式可能还会创建长的实例化链。 考虑以下断言。 ForAll([x, y], Implies(subtype(x, y),subtype(array_of(x), array_of(y))), patterns=[subtype(x, y)]) 只要存在形式子类型 subtype(s, t). 的某个基本项，就可以实例化公理。 该实例化会导致一个新的基础术语子类型subtype(array_of(s), array_of(t))，从而启用新的实例化。 这种不希望的情况称为匹配循环。 Z3使用许多启发式方法来打破匹配循环。 在详细说明细节之前，我们应该解决一个重要的第一个问题。 什么定义了搜索过程中创建的术语？ 在大多数SMT求解器和简化定理证明者的上下文中，术语作为输入公式的一部分存在， 它们当然也可以通过实例化量词来创建，但是当断言等式时也会隐式创建术语。 最后一点意味着要考虑所有项的全等，并且模式匹配以模地等式进行。 我们称匹配问题为E-matching。 例如，如果我们具有以下相等性： # 示例87 from z3 import * if __name__ == \"__main__\": f = Function('f', IntSort(), IntSort()) g = Function('g', IntSort(), IntSort()) a, b, c = Ints('a b c') x = Int('x') s = Solver() s.set(auto_config=False, mbqi=False) s.add(ForAll(x, f(g(x)) == x, patterns=[f(g(x))]), a == g(b),b == c,f(a) != c) print(s.check()) # unsat 项f（a）和f（g（b））在等式上相等。 可以匹配模式f（g（x））并将x绑定到b，并推导等式f（g（b））== b。 尽管E-matching是一个NP完全问题，但较大的验证问题中的间接费用的主要来源是在一组不断发展的术语和等式的背景下匹配数千种模式。 Z3使用术语索引技术集成了高效的E-matching引擎。 3、多种模式 在某些情况下，没有包含所有绑定变量且不包含解释符号的模式。 在这些情况下，我们使用多模式。 在下面的示例中，量化公式指出f为内射。 该量化公式使用多模式MultiPattern（f（x），f（y））注释。 # 示例88 from z3 import * if __name__ == \"__main__\": A = DeclareSort('A') B = DeclareSort('B') f = Function('f', A, B) a1, a2 = Consts('a1 a2', A) b = Const('b', B) x, y = Consts('x y', A) s = Solver() s.add(a1 != a2, f(a1) == b, f(a2) == b, ForAll([x, y], Implies(f(x) == f(y), x == y), patterns=[MultiPattern(f(x), f(y))]) ) print(s) print(s.check()) # unsat 对于每对出现的f实例化量化公式。 一个简单的技巧就可以以仅需要线性数量的实例化的方式来公式化f的内射性。 诀窍是要认识到f仅在具有部分逆的情况下才是内射的。 # 示例89 from z3 import * if __name__ == \"__main__\": A = DeclareSort('A') B = DeclareSort('B') f = Function('f', A, B) finv = Function('finv', B, A) a1, a2 = Consts('a1 a2', A) b = Const('b', B) x, y = Consts('x y', A) s = Solver() s.add(a1 != a2,f(a1) == b,f(a2) == b,ForAll(x, finv(f(x)) == x)) print(s) print(s.check()) # unsat 4、其他属性 在Z3Py中，支持以下附加属性： qid（用于调试的量化标识符）， 权重（到量化器实例化模块的提示：“更多的权重等于更少的实例”）， no_patterns（不应用作模式的表达式）， skid（标识符） 用于创建skolem常数/函数的前缀。 7、多重求解器 在Z3Py和Z3 4.0中，可以同时使用多个求解器。 将一个断言/公式从一个求解器复制到另一个求解器也很容易。 # 示例90 from z3 import * if __name__ == \"__main__\": x, y = Ints('x y') s1 = Solver() s1.add(x > 10, y > 10) s2 = Solver() # solver s2 is empty print(s2) # [] # copy assertions from s1 to s2 # 将断言从s1复制到s2 s2.add(s1.assertions()) print(s2) # [x > 10, y > 10] 8、Unsat Cores and Soft Constraints Z3Py还支持unsat core提取。 基本思想是使用假设，即我们要跟踪的辅助命题变量。 Z3 SMT 2.0前端和其他Z3前端中也提供了假设。 它们用于提取无法满足的核心。 它们也可以用来“撤消”约束。 请注意，假设并不是真正的软约束，但可以将其用于实施。 # 示例91 from z3 import * if __name__ == \"__main__\": p1, p2, p3 = Bools('p1 p2 p3') x, y = Ints('x y') # We assert Implies(p, C) to track constraint C using p # 我们断言Implies（p，C）使用p跟踪约束C s = Solver() s.add(Implies(p1, x > 10), Implies(p1, y > x), Implies(p2, y 0)) print(s) print() # Check satisfiability assuming p1, p2, p3 are true # 假设p1，p2，p3为真，则检查可满足性 print(s.check(p1, p2, p3)) # unsat print(s.unsat_core()) # [p1, p2] # Try again retracting p2 # 再试一次收回p2 print(s.check(p1, p3)) # sat print(s.model()) # [p3 = True, y = 12, p1 = True, p2 = False, x = 11] 上面的示例还显示了布尔变量（p1）可用于跟踪多个约束。 请注意，Z3不能保证非饱和核的数量最少。 9、格式化程序 Z3Py使用格式化程序（又称漂亮打印机）来显示公式，表达式，求解器和其他Z3对象。 格式化程序支持许多配置选项。 命令set_option（html_mode = False）使所有公式和表达式都以Z3Py表示法显示。 # 示例92 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') print(x ** 2 + y ** 2 >= 1) # x**2 + y**2 >= 1 set_option(html_mode=False) print(x ** 2 + y ** 2 >= 1) # x**2 + y**2 >= 1 默认情况下，如果显示的对象太大，则Z3Py将截断输出。 Z3Py使用…表示输出被截断。 可以设置以下配置选项来控制Z3Py格式化程序的行为： max_depth：最大表达式深度。 较深的表达式将替换为…。 max_args：每个节点要显示的最大参数数。 rational_to_decimal：如果为True，则将有理数显示为小数。 precision：以十进制表示法显示的数字的最大小数位数。 max_lines：要显示的最大行数。 max_width：最大线宽（这是对Z3Py的建议）。 max_indent：最大缩进。 # 示例93 from z3 import * if __name__ == \"__main__\": x = IntVector('x', 20) y = IntVector('y', 20) f = And(Sum(x) >= 0, Sum(y) >= 0) set_option(max_args=5) print(\"\\ntest 1:\") print(f) print(\"\\ntest 2:\") set_option(max_args=100, max_lines=10) print(f) print(\"\\ntest 3:\") set_option(max_width=300) print(f) Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/tutorial/2-Z3API_in_Python-Basics.html":{"url":"docs/tutorial/2-Z3API_in_Python-Basics.html","title":"2-Python中的z3 api-Basics","keywords":"","body":"Python中的z3 api-Basics 源地址：https://ericpony.github.io/z3py-tutorial/guide-examples.htm 1、介绍 Z3是由Microsoft Research开发的高性能定理证明器。 Z3用于许多应用程序，例如： 软件/硬件验证和测试，约束解决，混合系统分析，安全性，生物学（计算机模拟分析）和几何问题。 本教程演示了Z3Py的主要功能：Python中的Z3 API。 无需Python背景即可阅读本教程。 但是，在某个时候学习Python（一种有趣的语言！）非常有用， 并且有许多很棒的免费资源可供使用（Python教程）。 Z3发行版还包含C，.Net和OCaml API。 Z3Py的源代码可在Z3发行版中找到，可以随时对其进行修改以满足您的需求。 源代码还演示了如何在Z3 4.0中使用新功能。 Z3的其他出色前端包括Scala ^ Z3和SBV。 请向leonardo@microsoft.com发送反馈，评论和/或更正。 您的评论非常有价值。 2、入门 让我们从下面的简单示例开始： # 示例05 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') solve(x > 2, y 函数 Int('x') 在Z3中创建一个名为x的整数变量。 solve函数求解约束系统。 上面的示例使用两个变量x和y，以及三个约束。 像Python一样的Z3Py使用=进行赋值。 用于比较的运算符，> =，==和！=。 在上面的示例中，表达式x + 2 * y == 7是Z3约束。 Z3可以求解和处理公式。 下例显示了如何使用Z3公式/表达式简化器。 # 示例06 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') print(simplify(x + y + 2 * x + 3)) # 3 + 3*x + y print(simplify(x = 3, x ** 2 + x ** 2 + y ** 2 + 2 >= 5))) # And(x >= 2, 2*x**2 + y**2 >= 3) 默认情况下，Z3Py（用于Web）使用数学符号显示公式和表达式。 像往常一样，∧是逻辑，v是逻辑或，依此类推。 命令set_option（html_mode = False）使所有公式和表达式都以Z3Py表示法显示。 这也是Z3发行版随附的Z3Py脱机版本的默认模式。 # 示例07 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') print(x ** 2 + y ** 2 >= 1) # x**2 + y**2 >= 1 set_option(html_mode=False) print(x ** 2 + y ** 2 >= 1) # x**2 + y**2 >= 1 Z3提供了遍历表达式的功能。 # 示例08 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') n = x + y >= 3 print(\"num args: \", n.num_args()) # num args: 2 print(\"children: \", n.children()) # children: [x + y, 3] print(\"1st child:\", n.arg(0)) # 1st child: x + y print(\"2nd child:\", n.arg(1)) # 2nd child: 3 print(\"operator: \", n.decl()) # operator: >= print(\"op name: \", n.decl().name()) # op name: >= Z3提供所有基本的数学运算。 Z3Py使用与Python语言相同的运算符优先级。 像Python一样，**是幂运算符。 Z3可以解决非线性多项式约束。 # 示例09 from z3 import * if __name__ == \"__main__\": x = Real('x') # 实数 y = Real('y') print(simplify(And(x ** 2 + y ** 2 > 3, x ** 3 + y 3, x ** 3 + y 过程Real('x')创建实数变量x。 Z3Py可以表示任意大的整数，有理数（如上面的示例中所示）和无理代数。 无理数代数是具有整数系数的多项式的根。 在内部，Z3精确地表示所有这些数字。 无理数以十进制表示，以便于读取结果。 # 示例10 from z3 import * if __name__ == \"__main__\": x = Real('x') y = Real('y') solve(x ** 2 + y ** 2 == 3, x ** 3 == 2) # [y = -1.1885280594?, x = 1.2599210498?] set_option(precision=30) # 设置精度 print(\"Solving, and displaying result with 30 decimal places\") solve(x ** 2 + y ** 2 == 3, x ** 3 == 2) # [y = -1.188528059421316533710369365015?, # x = 1.259921049894873164767210607278?] set_option过程用于配置Z3环境。 它用于设置全局配置选项，例如结果的显示方式。 选项set_option(precision=30)设置显示结果时使用的小数位数。 这 ？ 标记在1.2599210498中？ 表示输出被截断。 以下示例演示了一个常见错误。 表达式3/2是Python整数，而不是Z3有理数。 该示例还显示了在Z3Py中创建有理数的不同方法。 过程 Q(num, den)创建一个Z3有理数，其中num是分子，den是分母。 RealVal(1)创建一个代表数字1的Z3实数。 # 示例11 from z3 import * if __name__ == \"__main__\": print(1 / 3) # 0.3333333333333333 print(RealVal(1) / 3) # 1/3 print(Q(1, 3)) # 1/3 x = Real('x') print(x + 1 / 3) # x + 3333333333333333/10000000000000000 print(x + Q(1, 3)) # x + 1/3 print(x + \"1/3\") # x + 1/3 print(x + 0.25) # x + 1/4 有理数也可以十进制表示。 # 示例12 from z3 import * if __name__ == \"__main__\": x = Real('x') solve(3 * x == 1) # [x = 1/3] set_option(rational_to_decimal=True) solve(3 * x == 1) # [x = 0.3333333333?] set_option(precision=30) solve(3 * x == 1) # [x = 0.333333333333333333333333333333?] 约束系统可能没有解决方案。 在这种情况下，我们说该系统不令人满意。 # 示例13 from z3 import * if __name__ == \"__main__\": x = Real('x') solve(x > 4, x 像在Python中一样，注释以井号字符＃开头，并在行尾终止。 Z3Py不支持跨越多行的注释。 # 示例14 from z3 import * if __name__ == \"__main__\": # This is a comment x = Real('x') # comment: creating x print(x ** 2 + 2 * x + 2) # x**2 + 2*x + 2 comment: 输出多项式 3、布尔逻辑 Z3支持布尔运算符：And, Or, Not, Implies (implication), If (if-then-else)。 “与”，“或”，“不”，“隐含”（蕴含），“隐含”（if-then-else）。 双含义使用等号==表示。 以下示例显示了如何解决一组简单的布尔约束。 # 示例15 from z3 import * if __name__ == \"__main__\": p = Bool('p') q = Bool('q') r = Bool('r') solve(Implies(p, q), r == Not(q), Or(Not(p), r)) # [q = True, p = False, r = False] Python布尔常量True和False可用于构建Z3布尔表达式。 # 示例16 from z3 import * if __name__ == \"__main__\": p = Bool('p') q = Bool('q') print(And(p, q, True)) # And(p, q, True) print(simplify(And(p, q, True))) # And(p, q) print(simplify(And(p, False))) # False 以下示例使用多项式约束和布尔约束的组合。 # 示例17 from z3 import * if __name__ == \"__main__\": p = Bool('p') x = Real('x') solve(Or(x 10), Or(p, x ** 2 == 2), Not(p)) # [x = -1.4142135623?, p = False] 4、Solvers Z3提供了不同的求解器。 先前示例中使用的命令Solve是使用Z3求解器API实现的。 可以在Z3发行版的z3.py文件中找到该实现。 下面的示例演示了基本的Solver API。 # 示例18 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') s = Solver() print(s) # [] s.add(x > 10, y == x + 2) print(s) # [x > 10, y == x + 2] print(\"Solving constraints in the solver s ...\") print(s.check()) # sat print(\"Create a new scope...\") s.push() s.add(y 10, y == x + 2, y 10, y == x + 2] print(\"Solving restored set of constraints...\") print(s.check()) # sat 命令Solver（）创建一个通用求解器。 可以使用add方法添加约束。 我们说约束已在求解器中确定。方法check（）解决断言的约束。 如果找到解决方案，则结果 sat（令人满意）。如果不存在任何解决方案，结果将是 unsat （无法满足）。 我们也可以说断言约束系统是不可行的。 最后，求解器可能无法求解约束系统，并且返回未知数。 在某些应用程序中，我们希望探讨共享多个约束的几个类似问题。 我们可以使用命令push和pop做到这一点。 每个求解器维护一堆断言。 命令push通过保存当前堆栈大小来创建新作用域。 pop命令删除在它和匹配的push之间执行的所有断言。 检查方法始终对求解器声明堆栈的内容进行操作。 以下示例显示了Z3无法解决的示例。 在这种情况下，求解器返回未知数。回想一下Z3可以解决非线性多项式约束，但是2 ** x不是多项式。 # 示例19 from z3 import * if __name__ == \"__main__\": x = Real('x') s = Solver() s.add(2 ** x == 3) print(s.check()) # unknown 下面的示例演示如何遍历声明到求解器中的约束，以及如何为check方法收集性能统计信息。 # 示例20 from z3 import * if __name__ == \"__main__\": x = Real('x') y = Real('y') s = Solver() s.add(x > 1, y > 1, Or(x + y > 3, x - y 当Z3为一组确定的约束找到解决方案时，命令检查返回sat。 我们说Z3满足约束集。 我们说解决方案是一组声明约束的模型。 模型是一种使每个声明的约束均成立的解释。 以下示例显示了检查模型的基本方法。 # 示例21 from z3 import * if __name__ == \"__main__\": x, y, z = Reals('x y z') s = Solver() s.add(x > 1, y > 1, x + y > 3, z - x 在上面的示例中，函数Reals（'x y z'）创建变量。 x，y和z。 它是以下各项的简写： x = Real('x') y = Real('y') z = Real('z') 表达式m [x]返回模型m中x的解释。 表达式\"%s = %s\" % (d.name(), m[d])返回一个字符串，其中第一个％s被替换为d的名称（即d.name（）），第二个被替换为d.name（）。 ％s带有d解释的文本表示形式（即m[d]）。 Z3Py会在需要时自动将Z3对象转换为文本表示形式。 5、算术（Arithmetic） Z3支持实数和整数变量。 可以将它们混合在一个问题中。 像大多数编程语言一样，Z3Py将在需要时自动添加强制转换，以将整数表达式转换为实数表达式。 下面的示例演示了声明整数和实数变量的不同方法。 # 示例22 from z3 import * if __name__ == \"__main__\": x = Real('x') y = Int('y') a, b, c = Reals('a b c') s, r = Ints('s r') print(x + y + 1 + (a + s)) # x + ToReal(y) + 1 + a + ToReal(s) print(ToReal(y) + c) # ToReal(y) + c 函数ToReal将整数表达式转换为实数表达式。 Z3Py支持所有基本的算术运算。 # 示例23 from z3 import * if __name__ == \"__main__\": a, b, c = Ints('a b c') d, e = Reals('d e') solve(a > b + 2, a == 2 * c + 10, c + b = e) # [d = 0, c = 0, b = 0, e = 0, a = 10] 该命令simple将简单的转换应用于Z3表达式。 # 示例24 from z3 import * if __name__ == \"__main__\": x, y = Reals('x y') # Put expression in sum-of-monomials form # 将表达式以总和形式表示 t = simplify((x + y) ** 3, som=True) # x*x*x + 3*x*x*y + 3*x*y*y + y*y*y print(t) # Use power operator # 使用power运算符 t = simplify(t, mul_to_power=True) # x**3 + 3*x**2*y + 3*x*y**2 + y**3 print(t) 命令helpsimplify（）打印所有可用选项。 Z3Py允许用户以两种样式编写选项。 Z3内部选项名称以：开头，单词之间用-分隔。 这些选项可以在Z3Py中使用。 Z3Py还支持类似Python的名称，其中：被抑制，而-被代替。 下面的示例演示如何使用两种样式。 # 示例25 from z3 import * if __name__ == \"__main__\": x, y = Reals('x y') # Using Z3 native option names # 使用Z3本地选项名称 print(simplify(x == y + 2, ':arith-lhs', True)) # x + -1*y == 2 # Using Z3Py option names # 使用Z3Py选项名称 print(simplify(x == y + 2, arith_lhs=True)) # x + -1*y == 2 print(\"\\nAll available options:\") help_simplify() Z3Py支持任意数量的数字。 下面的示例演示如何使用较大的整数，有理数和无理数执行基本算术。 Z3Py仅支持代数无理数。 代数无理数足以表示多项式约束系统的解。 Z3Py将始终以十进制表示形式显示非理性数字，因为它更易于阅读。 可以使用sexpr（）方法提取内部表示。 它以s表达式（类似于Lisp）表示法显示Z3内部表示的数学公式和表达式。 # 示例26 from z3 import * if __name__ == \"__main__\": x, y = Reals('x y') solve(x + 10000000000000000000000 == y, y > 20000000000000000) # [y = 20000000000000001, x = -9999979999999999999999] print(Sqrt(2) + Sqrt(3)) # 2**(1/2) + 3**(1/2) print(simplify(Sqrt(2) + Sqrt(3))) # 3.1462643699? print(simplify(Sqrt(2) + Sqrt(3)).sexpr()) # (root-obj (+ (^ x 4) (* (- 10) (^ x 2)) 1) 4) # The sexpr() method is available for any Z3 expression # sexpr（）方法可用于任何Z3表达式 print((x + Sqrt(y) * 2).sexpr()) # (+ x (* (^ y (/ 1.0 2.0)) 2.0)) 6、机器算术 位向量（bit vector）就是由一些二进制位组成的向量。 现代CPU和主流编程语言对固定大小的位向量使用算术运算。 Z3Py中的机器算法可作为位向量使用。 它们实现了无符号和带符号的两个补码算法的精确语义。 下面的示例演示如何创建位向量变量和常量。 函数BitVec('x', 16)在Z3中创建一个名为x的具有16位的位向量变量。 为了方便起见，可以使用整数常量在Z3Py中创建位向量表达式。 函数BitVecVal（10，32）创建一个大小为32的位向量，其中包含值10。 # 示例27 from z3 import * if __name__ == \"__main__\": x = BitVec('x', 16) y = BitVec('y', 16) print(x + 2) # x + 2 # Internal representation # 内部表示 print((x + 2).sexpr()) # (bvadd x #x0002) # -1 is equal to 65535 for 16-bit integers # 对于16位整数，-1等于65535 print(simplify(x + y - 1)) # 65535 + x + y # Creating bit-vector constants # 创建位向量常数 a = BitVecVal(-1, 16) b = BitVecVal(65535, 16) print(simplify(a == b)) # True a = BitVecVal(-1, 32) b = BitVecVal(65535, 32) # -1 is not equal to 65535 for 32-bit integers # 对于32位整数，-1不等于65535 print(simplify(a == b)) # False 与诸如C，C ++，C＃，Java之类的编程语言相比，有符号和无符号位向量之间没有区别。 取而代之的是，Z3提供了特殊的算术运算符号版本，在该版本中，将位向量视为带符号的还是无符号的都有所不同。 在Z3Py中，运算符，> =，/，％和>>对应于已签名的版本。 相应的无符号运算符是ULT，ULE，UGT，UGE，UDiv，URem和LShR。 # 示例28 from z3 import * if __name__ == \"__main__\": # Create to bit-vectors of size 32 x, y = BitVecs('x y', 32) solve(x + y == 2, x > 0, y > 0) # [y = 1, x = 1] # Bit-wise operators # & bit-wise and # | bit-wise or # ~ bit-wise not solve(x & y == ~y) # [x = 0, y = 4294967295] solve(x 运算符>>是算术右移， # 示例29 from z3 import * if __name__ == \"__main__\": # Create to bit-vectors of size 32 x, y = BitVecs('x y', 32) solve(x >> 2 == 3) # [x = 12] solve(x 7、函数 与编程语言不同，在编程语言中，函数具有副作用，可能引发异常或永远不会返回，而Z3中的函数则没有副作用，并且是合计的。 即，它们在所有输入值上定义。这包括除法等功能。 Z3基于一阶逻辑。 给定诸如x + y> 3的约束，我们一直在说x和y是变量。 在许多教科书中，x和y称为未解释的常量。 也就是说，它们允许任何与约束x + y> 3一致的解释。 更准确地说，纯一阶逻辑中的功能和常数符号是未解释的或自由的，这意味着没有附加先验的解释。 这与属于理论签名的函数相反，例如算术，其中函数+具有固定的标准解释（两个数字相加）。 未解释的函数和常量具有最大的灵活性；它们允许进行任何与函数或常量约束一致的解释。 为了说明未解释的函数和常量，让我们了解未解释的整数常量（又称变量）x，y。 最后，让f为一个未解释的函数，该函数接受一个类型（即排序）整数的参数，并得出一个整数值。 该示例说明了如何强制解释，其中对x两次应用f会再次导致x，但是对x一次应用f与x不同。 # 示例30 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') f = Function('f', IntSort(), IntSort()) solve(f(f(x)) == x, f(x) == y, x != y) # [x = 0, y = 1, f = [1 -> 0, else -> 1]] f的解（解释）应读为f（0）为1，f（1）为0，而f（a）为1，表示所有0和1都不相同。 在Z3中，我们还可以为约束系统评估模型中的表达式。 下面的示例演示如何使用评估方法。 # 示例31 from z3 import * if __name__ == \"__main__\": x = Int('x') y = Int('y') f = Function('f', IntSort(), IntSort()) s = Solver() s.add(f(f(x)) == x, f(x) == y, x != y) print(s.check()) # sat m = s.model() print(\"f(f(x)) =\", m.evaluate(f(f(x)))) # f(f(x)) = 0 print(\"f(x) =\", m.evaluate(f(x))) # f(x) = 1 print(m) # [x = 0, y = 1, f = [1 -> 0, else -> 1]] 8、可满足性和有效性 如果F始终对其未解释的符号分配适当的值，则公式/约束F有效。 如果对公式/约束F的未解释符号进行了一些适当的赋值，则F满足true，则公式/约束F是可满足的。 有效性在于寻找陈述的证明；可满足性是关于找到一组约束的解决方案。 考虑包含a和b的公式F。我们可以问F是否有效，即对于a和b的值的任何组合，它是否始终为真。 如果F始终为true，则Not（F）始终为false，然后Not（F）将没有任何令人满意的分配（即解决方案）; 也就是说，Not（F）是不令人满意的。 也就是说，当Not（F）不能满足（不满足）时，F正好有效。 或者，当且仅当Not（F）无效（无效）时，F才可满足。以下示例证明了德摩根定律。 下面的示例重新定义了Z3Py函数，该函数证明接收公式作为参数。 此函数创建一个求解器，添加/声明公式的求反，并检查是否不能满足求反。 此功能的实现是Z3Py命令证明的较简单版本。 # 示例32 from z3 import * if __name__ == \"__main__\": p, q = Bools('p q') demorgan = And(p, q) == Not(Or(Not(p), Not(q))) print(demorgan) # And(p, q) == Not(Or(Not(p), Not(q))) def prove(f): s = Solver() s.add(Not(f)) if s.check() == unsat: print(\"proved\") # proved else: print(\"failed to prove\") print(\"Proving demorgan...\") prove(demorgan) 9、列表推导 Python支持列表推导。 列表理解为创建列表提供了一种简洁的方法。 它们可用于在Z3Py中创建Z3表达式和问题。 以下示例演示了如何在Z3Py中使用Python列表推导。 # 示例33 from z3 import * if __name__ == \"__main__\": # Create list [1, ..., 5] # 创建列表[1，...，5] print([x + 1 for x in range(5)]) # [1, 2, 3, 4, 5] # Create two lists containing 5 integer variables # 创建两个包含5个整数变量的列表 X = [Int('x%s' % i) for i in range(5)] Y = [Int('y%s' % i) for i in range(5)] print(X) # [x0, x1, x2, x3, x4] # Create a list containing X[i]+Y[i] # 创建一个包含X [i] + Y [i]的列表 X_plus_Y = [X[i] + Y[i] for i in range(5)] print(X_plus_Y) # [x0 + y0, x1 + y1, x2 + y2, x3 + y3, x4 + y4] # Create a list containing X[i] > Y[i] # 创建一个包含X [i]> Y [i]的列表 X_gt_Y = [X[i] > Y[i] for i in range(5)] print(X_gt_Y) # [x0 > y0, x1 > y1, x2 > y2, x3 > y3, x4 > y4] print(And(X_gt_Y)) # And(x0 > y0, x1 > y1, x2 > y2, x3 > y3, x4 > y4) # Create a 3x3 \"matrix\" (list of lists) of integer variables # 创建一个3x3的“矩阵”（列表列表）整数变量 X = [[Int(\"x_%s_%s\" % (i + 1, j + 1)) for j in range(3)] for i in range(3)] pp(X) 在上面的示例中，表达式“ x％s”％i返回一个字符串，其中％s被替换为i的值。 pp命令与print相似，但是它使用Z3Py格式化程序来处理列表和元组，而不是Python的格式化程序。 Z3Py还提供了用于创建布尔，整数和实数变量的向量的函数。 这些功能是使用列表推导来实现的。 # 示例34 from z3 import * if __name__ == \"__main__\": X = IntVector('x', 5) Y = RealVector('y', 5) P = BoolVector('p', 5) print(X) # [x__0, x__1, x__2, x__3, x__4] print(Y) # [y__0, y__1, y__2, y__3, y__4] print(P) # [p__0, p__1, p__2, p__3, p__4] print([y ** 2 for y in Y]) # [y__0**2, y__1**2, y__2**2, y__3**2, y__4**2] print(Sum([y ** 2 for y in Y])) # y__0**2 + y__1**2 + y__2**2 + y__3**2 + y__4**2 10、运动方程（Kinematic Equations） 在高中，学生学习运动方程。 这些方程式描述了位移（d），时间（t），加速度（a），初始速度（v_i）和最终速度（v_f）之间的数学关系。 用Z3Py表示法，我们可以将这些方程写为： d == v_i * t + (a*t**2)/2, v_f == v_i + a*t 1、问题1 Ima Hurryin正在接近一个以30.0 m / s的速度移动的信号灯。 指示灯变黄，Ima踩下刹车并打滑。 如果Ima的加速度为-8.00 m/s^2，则在打滑过程中确定汽车的排量。 # 示例35 from z3 import * if __name__ == \"__main__\": d, a, t, v_i, v_f = Reals('d a t v__i v__f') equations = [ d == v_i * t + (a * t ** 2) / 2, v_f == v_i + a * t, ] print(\"Kinematic equations:\") print(equations) # [d == v__i*t + (a*t**2)/2, v__f == v__i + a*t] # Given v_i, v_f and a, find d problem = [ v_i == 30, v_f == 0, a == -8 ] print(\"Problem:\") print(problem) # [v__i == 30, v__f == 0, a == -8] print(\"Solution:\") solve(equations + problem) # [a = -8, v__f = 0, v__i = 30, t = 15/4, d = 225/4] 2、问题2 本·鲁辛（Ben Rushin）正在红绿灯前等待。 当它最终变为绿色时，Ben以6.00 m / s2的速度从静止加速了4.10秒。 确定这段时间内本汽车的排量。 # 示例36 from z3 import * if __name__ == \"__main__\": d, a, t, v_i, v_f = Reals('d a t v__i v__f') equations = [ d == v_i * t + (a * t ** 2) / 2, v_f == v_i + a * t, ] # Given v_i, t and a, find d problem = [ v_i == 0, t == 4.10, a == 6 ] solve(equations + problem) # [a = 6, t = 41/10, v__i = 0, v__f = 123/5, d = 5043/100] # Display rationals in decimal notation # 用十进制表示法显示有理数 set_option(rational_to_decimal=True) solve(equations + problem) # [a = 6, t = 4.1, v__i = 0, v__f = 24.6, d = 50.43] 11、位技巧 一些低级hack在C程序员中非常流行。 我们在Z3实现中使用了其中一些技巧。 1、二次方 此hack经常在C程序（包括Z3）中使用，以测试机器整数是否为2的幂。 我们可以使用Z3证明它确实有效。 声称x！= 0 &&！（x＆（x-1））为真，且仅当x为2的幂时才成立。 # 示例37 from z3 import * if __name__ == \"__main__\": x = BitVec('x', 32) powers = [2 ** i for i in range(32)] fast = And(x != 0, x & (x - 1) == 0) slow = Or([x == p for p in powers]) print(fast) # And(x != 0, x & x - 1 == 0) prove(fast == slow) # proved print(\"trying to prove buggy version...\") fast = x & (x - 1) == 0 prove(fast == slow) # counterexample # [x = 0] 2、相反的符号 以下简单技巧可用于测试两个机器整数是否具有相反的符号。 # 示例38 from z3 import * if __name__ == \"__main__\": x = BitVec('x', 32) y = BitVec('y', 32) # Claim: (x ^ y) = 0), And(x >= 0, y 12、难题 1、狗，猫和老鼠 考虑以下难题。 正好花了100美元，正好买了100只动物。 狗的价格为15美元，猫的价格为1美元，小鼠的价格为25美分。 您必须至少购买其中之一。 您应该购买多少个？ # 示例39 from z3 import * if __name__ == \"__main__\": # Create 3 integer variables dog, cat, mouse = Ints('dog cat mouse') s = Solver() s.add(dog >= 1) # 至少一只狗 s.add(cat >= 1) # 至少一只猫 s.add(mouse >= 1) # 至少一只老鼠 s.add(dog + cat + mouse == 100) # 我们想买100只动物 s.add(1500 * dog + 100 * cat + 25 * mouse == 10000) # 我们有100美元（10000美分） # 狗的费用为15美元（1500美分） # 猫的售价为1美元（100美分） # 老鼠花了25美分 print(s) print(s.check()) print(s.model()) # [cat = 41, mouse = 56, dog = 3] 2、数独 数独是一个非常受欢迎的难题。 目标是将数字插入框中仅满足一个条件： 每一行，每一列和3x3框必须只包含一次1到9的数字。 以下示例对Z3中的数独问题进行了编码。 可以通过修改矩阵实例来解决不同的数独实例。 此示例大量使用了Python编程语言中的列表推导。 # 示例40 from z3 import * if __name__ == \"__main__\": # 9x9 matrix of integer variables # 9x9整数变量矩阵 X = [[Int(\"x_%s_%s\" % (i + 1, j + 1)) for j in range(9)] for i in range(9)] # each cell contains a value in {1, ..., 9} # 每个单元格都包含{1，...，9}中的值 cells_c = [And(1 3、八皇后 八皇后难题是将八个国际象棋皇后放在8x8棋盘上的问题，这样就不会有两个皇后互相攻击。 因此，解决方案要求没有两个皇后共享相同的行，列或对角线。 # 示例41 from z3 import * if __name__ == \"__main__\": # We know each queen must be in a different row. # So, we represent each queen by a single integer: the column position # 我们知道每个女王都必须在不同的行中。 # 因此，我们用一个整数表示每个皇后：列位置 Q = [Int('Q_%i' % (i + 1)) for i in range(8)] # Each queen is in a column {1, ... 8 } # 每个女王都在{1，... 8}列中 val_c = [And(1 13、应用程序：安装问题 最佳软件包安装/卸载管理器：http://cseweb.ucsd.edu/~rjhala/papers/opium.pdf 安装问题包括确定是否可以在系统中安装一组新的软件包。 此应用程序基于文章OPIUM：最佳软件包安装/卸载管理器。 许多软件包都依赖于其他软件包来提供某些功能。 每个发行版都包含一个元数据文件，该文件说明了该发行版每个程序包的要求。 元数据包含详细信息，例如名称，版本等。 更重要的是，它包含depends和conflicts子句，这些子句规定了系统上还应该安装其他软件包。 Depends子句规定必须存在哪些其他软件包。 冲突条款规定不得存在其他软件包。 使用Z3可以轻松解决安装问题。 这个想法是为每个包定义一个布尔变量。 如果程序包必须在系统中，则此变量为true。 如果程序包a依赖于程序包b，c和z，我们将这样写： DependsOn(a, [b, c, z]) def DependsOn(pack, deps): return And([ Implies(pack, dep) for dep in deps ]) And(Implies(a, b), Implies(a, c), Implies(a, z)) DependsOn是一个简单的Python函数，它创建Z3约束来捕获Depends子句的语义。 因此，依赖项（a，[b，c，z]）生成约束。 也就是说，如果用户安装了软件包a，那么他们还必须安装软件包b、c和z。 如果包d与包e冲突，我们就写Conflict（d，e）。 Conflict也是一个简单的Python函数。 def Conflict(p1, p2): return Or(Not(p1), Not(p2)) 冲突（d，e）生成约束 Or(Not(d), Not(e))。 通过这两个函数，我们可以很容易地将Z3Py中的安装paper（第2节）中的示例编码为： # 示例42 from z3 import * if __name__ == \"__main__\": def DependsOn(pack, deps): return And([Implies(pack, dep) for dep in deps]) def Conflict(p1, p2): return Or(Not(p1), Not(p2)) a, b, c, d, e, f, g, z = Bools('a b c d e f g z') solve(DependsOn(a, [b, c, z]), DependsOn(b, [d]), DependsOn(c, [Or(d, e), Or(f, g)]), Conflict(d, e), a, z) # [f = True, # b = True, # a = True, # d = True, # g = False, # z = True, # c = True, # e = False] 请注意，该示例包含约束 DependsOn(c, [Or(d, e), Or(f, g)]), 含义是：要安装c，必须安装d或e，以及f或g 现在，我们完善前面的示例。 首先，我们修改DependsOn以允许我们编写DependsOn（b，d）而不是DependsOn（b，[d]）。 我们还编写了一个函数install_check，该函数返回必须在系统中安装的软件包的列表。 功能冲突也被修改。 现在，它可以接收多个参数。 # 示例43 from z3 import * if __name__ == \"__main__\": def DependsOn(pack, deps): if is_expr(deps): return Implies(pack, deps) else: return And([Implies(pack, dep) for dep in deps]) def Conflict(*packs): return Or([Not(pack) for pack in packs]) def install_check(*problem): s = Solver() s.add(*problem) if s.check() == sat: m = s.model() r = [] for x in m: if is_true(m[x]): # x is a Z3 declaration # x() returns the Z3 expression # x.name() returns a string r.append(x()) print(r) else: print(\"invalid installation profile\") a, b, c, d, e, f, g, z = Bools('a b c d e f g z') print(\"Check 1\") # [f, b, a, d, z, c] install_check(DependsOn(a, [b, c, z]),DependsOn(b, d), DependsOn(c, [Or(d, e), Or(f, g)]), Conflict(d, e),Conflict(d, g), a, z) print(\"Check 2\") # invalid installation profile install_check(DependsOn(a, [b, c, z]),DependsOn(b, d), DependsOn(c, [Or(d, e), Or(f, g)]), Conflict(d, e),Conflict(d, g), a, z, g) 14、在本地使用Z3Py Z3Py是Z3发行版的一部分。 它位于python子目录中。 要在本地使用它，您必须在Python脚本中包含以下命令。 from Z3 import * Z3 Python前端目录必须位于您的PYTHONPATH环境变量中。 Z3Py将自动搜索Z3库（z3.dll（Windows），libz3.so（Linux）或libz3.dylib（OSX））。 您也可以使用以下命令手动初始化Z3Py： init(\"z3.dll\") Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/tutorial/2-Z3API_in_Python-Fixedpoints.html":{"url":"docs/tutorial/2-Z3API_in_Python-Fixedpoints.html","title":"2-Python中的z3 api-Fixedpoints","keywords":"","body":"Python中的z3 api-Fixedpoints 源地址：https://ericpony.github.io/z3py-tutorial/fixpoint-examples.htm 本教程说明了Z3的定点引擎的用法。 以下论文μZ - An Efficient Engine for Fixed-Points with Constraints （CAV 2011）和Generalized Property Directed Reachability（SAT 2012）描述了引擎的一些主要功能。 请向nbjorner@microsoft.com发送反馈，评论和/或更正。 1、介绍 本教程介绍了Z3可用的一些定点实用程序。 主要功能是基本的Datalog引擎，具有关系代数的引擎以及基于属性定向可达性算法的泛化的引擎。 2、Basic Datalog 默认的定点引擎是自底向上的Datalog引擎。 它适用于有限关系，并且使用有限表表示形式作为哈希表作为表示有限关系的默认方式。 1、关系，规则和查询 第一个示例说明了如何声明关系，规则以及如何提出查询。 # 示例55 from z3 import * if __name__ == \"__main__\": fp = Fixedpoint() a, b, c = Bools('a b c') fp.register_relation(a.decl(), b.decl(), c.decl()) # 申明关系 fp.rule(a, b) # 定义规则 fp.rule(b, c) fp.set(engine='datalog') # 设置引擎 print(\"current set of rules\", ) print(fp) # (declare - rel b ()) # (declare - rel a ()) # (declare - rel c ()) # (rule(= > ( and b) a)) # (rule(= > ( and c) b)) # 查询规则 print(fp.query(a)) # unsat fp.fact(c) print(\"updated set of rules\", ) print(fp) # (declare - rel b ()) # (declare - rel a ()) # (declare - rel c ()) # (rule(= > b a)) # (rule(= > c b)) # (rule c) print(fp.query(a)) # sat print(fp.get_answer()) # True 该示例说明了一些基本构造。 fp = Fixedpoint() 创建定点计算的上下文。 fp.register_relation(a.decl(), b.decl(), c.decl()) 将关系a，b，c注册为递归定义的。 fp.rule(a,b) 创建b遵循a的规则。 通常，您可以使用以下格式创建包含多个前提和名称的规则 fp.rule(head,[body1,...,bodyN],name) 名称是可选的。 它用于跟踪推导证明中的规则。 继续该示例，除非建立了b，否则a为假。 fp.query(a) 询问是否可以派生a。 到目前为止的规则说，如果建立了b，则a遵循，同时如果建立c，则b遵循。 但是没有建立c的事物，也没有建立b的事物，因此不能导出a。 fp.fact(c) 添加一个事实fp.rule(c,True)的简写。 现在是可以导出a的情况。 2、解释说明 也可能获得对派生查询的解释。 对于有限的Datalog引擎，解释是一种跟踪，它提供有关如何得出事实的信息。 解释是一个表达式，其功能符号是推导中使用的Horn规则和事实。 # 示例56 from z3 import * if __name__ == \"__main__\": fp = Fixedpoint() a, b, c = Bools('a b c') fp.register_relation(a.decl(), b.decl(), c.decl()) fp.rule(a, b) fp.rule(b, c) fp.fact(c) # 会报错=> \"unknown parameter 'generate_explanations' # fp.set(generate_explanations=True, engine='datalog') fp.set(engine='datalog') print(fp.query(a)) # sat print(fp.get_answer()) # True 3、与arguments的关系 关系可以引起arguments。 我们使用图形中的边和路径来说明与arguments的关系。 # 示例57 from z3 import * if __name__ == \"__main__\": fp = Fixedpoint() fp.set(engine='datalog') s = BitVecSort(3) edge = Function('edge', s, s, BoolSort()) path = Function('path', s, s, BoolSort()) a = Const('a', s) b = Const('b', s) c = Const('c', s) fp.register_relation(path, edge) fp.declare_var(a, b, c) fp.rule(path(a, b), edge(a, b)) fp.rule(path(a, c), [edge(a, b), path(b, c)]) v1 = BitVecVal(1, s) v2 = BitVecVal(2, s) v3 = BitVecVal(3, s) v4 = BitVecVal(4, s) fp.fact(edge(v1, v2)) fp.fact(edge(v1, v3)) fp.fact(edge(v2, v4)) print(\"current set of rules\") print(fp) # (declare - rel path ((_ BitVec 3)(_ BitVec 3))) # (declare - rel edge ((_ BitVec 3)(_ BitVec 3))) # (declare - var A (_ BitVec 3)) # (declare - var B (_ BitVec 3)) # (declare - var C (_ BitVec 3)) # (rule(= > ( and (edge C B)) (path C B))) # (rule(= > ( and (edge C B)(path B A)) (path C A))) # (rule(edge # b001 #b010)) # (rule(edge # b001 #b011)) # (rule(edge # b010 #b100)) print() print(fp.query(path(v1, v4)), \"yes we can reach v4 from v1\") # sat yes we can reach v4 from v1 print(fp.query(path(v3, v4)), \"no we cannot reach v4 from v3\") # unsat no we cannot reach v4 from v3 该示例使用了声明 fp.declare_var(a,b,c) 以指示定点引擎在规则中出现a，b，c时应将其视为变量。 考虑一下约定，因为它们将绑定变量传递给Z3Py中的量词。 4、尖峰时刻 使用基本定点引擎的一个更有趣的示例是解决“高峰时间”难题。 | 难题在于将一辆红色汽车移出僵局。 我们已经对配置进行了编码，并编译了一组规则，这些规则对给定配置的汽车的合法移动进行了编码。 可以通过更改传递给Car的构造函数的参数来测试其他配置。 我们已经编码了一个在线拼图中的配置，您可以手动解决它，也可以通过询问Z3来作弊。 # 示例58 # todo 待理解 from z3 import * class Car: def __init__(self, is_vertical, base_pos, length, start, color): self.is_vertical = is_vertical self.base = base_pos self.length = length self.start = start self.color = color def __eq__(self, other): return self.color == other.color def __ne__(self, other): return self.color != other.color def num(i): return BitVecVal(i, bv3) def bound(i): return Const(cars[i].color, bv3) def mk_state(car_node, value): return state([(num(value) if (cars[i] == car_node) else bound(i)) for i in range(num_cars)]) def mk_transition(row, col, i0, j, car0): body = [mk_state(car0, i0)] for index in range(num_cars): car_node = cars[index] if car0 != car_node: if car_node.is_vertical and car_node.base == col: for i in range(dimension): if i %d\" % (car0.color, i0, j) fp.rule(mk_state(car0, j), body, s) def move_down(i, car): free_row = i + car.length if free_row 0: print(trace.decl()) trace = trace.children()[-1] if __name__ == \"__main__\": dimension = 6 red_car = Car(False, 2, 2, 3, \"red\") cars = [ Car(True, 0, 3, 0, 'yellow'), Car(False, 3, 3, 0, 'blue'), Car(False, 5, 2, 0, \"brown\"), Car(False, 0, 2, 1, \"lgreen\"), Car(True, 1, 2, 1, \"light blue\"), Car(True, 2, 2, 1, \"pink\"), Car(True, 2, 2, 4, \"dark green\"), red_car, Car(True, 3, 2, 3, \"purple\"), Car(False, 5, 2, 3, \"light yellow\"), Car(True, 4, 2, 0, \"orange\"), Car(False, 4, 2, 4, \"black\"), Car(True, 5, 3, 1, \"light purple\") ] num_cars = len(cars) print(\"car number is \", num_cars) B = BoolSort() bv3 = BitVecSort(3) state = Function('state', [bv3 for c in cars] + [B]) fp = Fixedpoint() # 会报错=>\"unknown parameter 'generate_explanations' # fp.set(generate_explanations=True) fp.declare_var([bound(i) for i in range(num_cars)]) fp.register_relation(state) # Initial state: # 初始状态： fp.fact(state([num(cars[i].start) for i in range(num_cars)])) # Transitions: # 过渡： for car in cars: for i in range(dimension): if car.is_vertical: move_down(i, car) move_up(i, car) else: move_left(i, car) move_right(i, car) print(fp) goal = state([(num(4) if cars[i] == red_car else bound(i)) for i in range(num_cars)]) fp.query(goal) get_instructions(fp.get_answer()) 3、抽象领域 基础引擎使用基于关系代数的表操作。 表示对于底层引擎是不透明的。 关系代数运算为任意关系定义得很好。 它们不依赖于关系是表示一组有限值还是一组无限值。 Z3包含两个用于无限域的内置表。 第一个是整数和实数的间隔。第二个是用于两个整数或实数之间的边界约束。 绑定约束的形式为x或x。当结合使用时，它们形成一个抽象域，称为五角大楼抽象域。 Z3实现了抽象域的精简乘积，从而使间隔域和边界域之间可以共享约束。 下面我们给出一个简单的示例，说明位置10处的循环。 只要循环计数器不超过上限，循环就会递增。 使用边界域和区间域的组合，我们可以从循环中收集派生的不变量，并且我们还可以确定循环后的状态不超过边界。 # 示例59 from z3 import * # 执行出错 # todo if __name__ == \"__main__\": I = IntSort() B = BoolSort() l0 = Function('l0', I, I, B) l1 = Function('l1', I, I, B) s = Fixedpoint() # 会报错=> \"unknown parameter 'compile_with_widening' # 会报错=> \"unknown parameter 'unbound_compressor' # s.set(engine='datalog', compile_with_widening=True, unbound_compressor=False) s.set(engine='datalog') s.set('datalog.compile_with_widening', True) s.register_relation(l0, l1) s.set_predicate_representation(l0, 'interval_relation', 'bound_relation') s.set_predicate_representation(l1, 'interval_relation', 'bound_relation') m, x, y = Ints('m x y') s.declare_var(m, x, y) s.rule(l0(0, m), 0 该示例使用选项，Z3将抽象解释扩展到循环边界上。 set_option(dl_compile_with_widening=True) 4、属性导向可达性引擎 用于定点的不同底层引擎基于属性定向可达性（PDR）的算法。 使用以下指令启用PDR引擎 set_option(dl_engine=1) Z3中的版本适用于具有算术和布尔域的Horn子句。 使用算术时，应启用Z3中使用的主要抽象引擎进行PDR中的算术。 set_option(dl_pdr_use_farkas=True) 该引擎还可以使用代数数据类型和位向量与域一起使用，尽管目前还没有针对任何一种进行过调优。 PDR引擎针对软件符号模型检查中的应用程序。 该系统可以是无限状态。 以下示例还旨在说明如何将软件模型检查问题（具有安全属性）嵌入到Horn子句中并使用PDR解决。 1、程序调用 McCarthy的91函数说明了一个过程，该过程递归调用两次。 下面的Horn子句对递归函数进行编码： mc(x) = if x > 100 then x - 10 else mc(mc(x+11)) 编码递归过程的一般方案是为每个过程创建一个谓词，并向该谓词添加一个附加的输出变量。 可以将对主体内过程的嵌套调用编码为关系的结合。 # 示例60 from z3 import * # 执行出错 # todo if __name__ == \"__main__\": mc = Function('mc', IntSort(), IntSort(), BoolSort()) n, m, p = Ints('n m p') fp = Fixedpoint() fp.declare_var(n, m) fp.register_relation(mc) fp.rule(mc(m, m - 10), m > 100) fp.rule(mc(m, n), [m 前两个查询是无法满足的。 PDR引擎产生了同样的不满足的证据。 证明是每个递归谓词的归纳不变式。 PDR引擎为查询引入了特殊的查询谓词。 2、Bakery 我们还可以证明反应系统的不变性。 将反应系统编码为保护过渡系统非常方便。 直接编码受保护的转换可能不像递归的Horn子句那样方便。 但是从受保护的过渡系统到递归的Horn子句编写翻译器是相当容易的。 在下一个示例中，我们将说明翻译器和Lamport的两个过程Bakery算法。 产生相当冗长（绝不是最小）的归纳不变量作为答案。 # 示例61 # todo 待理解 from z3 import * def flatten(l): return [s for t in l for s in t] class TransitionSystem(): def __init__(self, initial, transitions, vars1): self.fp = Fixedpoint() self.initial = initial self.transitions = transitions self.vars1 = vars1 def declare_rels(self): B = BoolSort() var_sorts = [v.sort() for v in self.vars1] state_sorts = var_sorts self.state_vals = [v for v in self.vars1] self.state_sorts = state_sorts self.var_sorts = var_sorts self.state = Function('state', state_sorts + [B]) self.step = Function('step', state_sorts + state_sorts + [B]) self.fp.register_relation(self.state) self.fp.register_relation(self.step) # Set of reachable states are transitive closure of step. # 一组可到达状态是步骤的可传递关闭。 def state0(self): idx = range(len(self.state_sorts)) return self.state([Var(i, self.state_sorts[i]) for i in idx]) def state1(self): n = len(self.state_sorts) return self.state([Var(i + n, self.state_sorts[i]) for i in range(n)]) def rho(self): n = len(self.state_sorts) args1 = [Var(i, self.state_sorts[i]) for i in range(n)] args2 = [Var(i + n, self.state_sorts[i]) for i in range(n)] args = args1 + args2 return self.step(args) def declare_reachability(self): self.fp.rule(self.state1(), [self.state0(), self.rho()]) # Define transition relation # 定义过渡关系 def abstract(self, e): n = len(self.state_sorts) sub = [(self.state_vals[i], Var(i, self.state_sorts[i])) for i in range(n)] return substitute(e, sub) def declare_transition(self, tr): len_s = len(self.state_sorts) effect = tr[\"effect\"] vars1 = [Var(i, self.state_sorts[i]) for i in range(len_s)] + effect rho1 = self.abstract(self.step(vars1)) guard = self.abstract(tr[\"guard\"]) self.fp.rule(rho1, guard) def declare_transitions(self): for t in self.transitions: self.declare_transition(t) def declare_initial(self): self.fp.rule(self.state0(), [self.abstract(self.initial)]) def query(self, query): self.declare_rels() self.declare_initial() self.declare_reachability() self.declare_transitions() query = And(self.state0(), self.abstract(query)) print(self.fp) print(query) print(self.fp.query(query)) print(self.fp.get_answer()) if __name__ == \"__main__\": set_option(relevancy=0, verbose=1) # print self.fp.statistics() L = Datatype('L') L.declare('L0') L.declare('L1') L.declare('L2') L = L.create() L0 = L.L0 L1 = L.L1 L2 = L.L2 y0 = Int('y0') y1 = Int('y1') l = Const('l', L) m = Const('m', L) t1 = {\"guard\": l == L0, \"effect\": [L1, y1 + 1, m, y1]} t2 = {\"guard\": And(l == L1, Or([y0 3、功能程序 Predicate Abstraction and CEGAR for Higher-Order Model Checking, Kobayashi et.al. PLDI 2011 我们还可以使用Z3的广义PDR验证功能程序的某些属性。 让我们在这里考虑来自Kobayashi等人的谓词抽象和CEGAR中用于高阶模型检查的示例。 PLDI2011。 我们通过采用适当的操作语义并对功能代码进行编码，以对要验证的程序专用的评估程序进行编码（我们不对通用评估程序进行编码，您应该对通用评估程序进行部分评估以帮助验证）。 我们使用代数数据类型对正在评估的当前闭包进行编码。 # 示例62 from z3 import * # 执行出错 # todo if __name__ == \"__main__\": # let max max2 x y z = max2 (max2 x y) z # let f x y = if x > y then x else y # assert (f (max f x y z) x) = (max f x y z) Expr = Datatype('Expr') Expr.declare('Max') Expr.declare('f') Expr.declare('I', ('i', IntSort())) Expr.declare('App', ('fn', Expr), ('arg', Expr)) Expr = Expr.create() Max = Expr.Max I = Expr.I App = Expr.App f = Expr.f Eval = Function('Eval', Expr, Expr, Expr, BoolSort()) x = Const('x', Expr) y = Const('y', Expr) z = Const('z', Expr) r1 = Const('r1', Expr) r2 = Const('r2', Expr) max = Const('max', Expr) xi = Const('xi', IntSort()) yi = Const('yi', IntSort()) fp = Fixedpoint() fp.register_relation(Eval) fp.declare_var(x, y, z, r1, r2, max, xi, yi) # Max max x y z = max (max x y) z fp.rule(Eval(App(App(App(Max, max), x), y), z, r2), [Eval(App(max, x), y, r1), Eval(App(max, r1), z, r2)]) # f x y = x if x >= y # f x y = y if x = yi) fp.rule(Eval(App(f, I(xi)), I(yi), I(yi)), xi Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/tutorial/2-Z3API_in_Python-Strategies.html":{"url":"docs/tutorial/2-Z3API_in_Python-Strategies.html","title":"2-Python中的z3 api-Strategies","keywords":"","body":"Python中的z3 api-Strategies 源地址：https://ericpony.github.io/z3py-tutorial/strategies-examples.htm 诸如Z3之类的高性能求解器包含许多算法证明方法的紧密集成，手工制作的启发式组合。 尽管这些启发式组合往往针对已知的问题类别进行了高度调整，但它们在新的问题类别上可能很容易表现很差。 随着求解器开始引起科学和工程学各个领域的从业者的注意，这个问题变得越来越紧迫。 在许多情况下，更改求解器试探法可能会带来巨大的不同。 在本教程中，我们将展示如何使用Z3中可用的基本构建块来创建自定义策略。 Z3Py和Z3 4.0实现了本文提出的思想。 请向leonardo@microsoft.com发送反馈，评论和/或更正。 您的评论非常有价值。 http://research.microsoft.com/en-us/um/people/leonardo/strategy.pdf 1、介绍 Z3实现了一种用于编排推理引擎的方法，其中将“大”符号推理步骤表示为称为战术的功能， 并且使用称为战术的组合器来组成战术。战术处理称为目标的公式集。 将策略应用于某个目标G时，可能会有四个不同的结果。 该策略成功地表明G是可满足的（即可行的）； 成功表明G不满足要求（即不可行）; 产生一系列子目标； 或失败。 当将目标G减少为子目标G1，...，Gn的序列时，我们面临模型转换的问题。 模型转换器使用一些子目标Gi的模型构造G的模型。 在下面的示例中，我们创建一个目标g，该目标g由三个公式组成，一个策略t由两个内置策略组成： simple和solve-eqs。 简化策略将应用等效于命令simple的转换。 战术solver-eqs使用高斯消除法消除变量。 实际上，solve-eqs不仅仅限于线性算术。它还可以消除任意变量。 然后，组合器then将simplify应用于输入目标，并对由simplify产生的每个子目标求解等式。 在此示例中，仅生成一个子目标。 # 示例44 from z3 import * if __name__ == \"__main__\": x, y = Reals('x y') g = Goal() g.add(x > 0, y > 0, x == y + 2) print(g) # [x > 0, y > 0, x == y + 2] t1 = Tactic('simplify') t2 = Tactic('solve-eqs') t = Then(t1, t2) print(t(g)) # [[Not(y 在上面的示例中，变量x被消除，并且不代表最终目标。 在Z3中，我们说一个子句是形式为Or（f_1，...，f_n）的任何约束。 战术拆分子句将在输入目标中选择子句Or（f_1，...，f_n），并将其拆分为n个子目标。 每个子公式f_i一个。 # 示例45 from z3 import * if __name__ == \"__main__\": x, y = Reals('x y') g = Goal() g.add(Or(x 0), x == y + 1, y 0, x == y + 1, y 2、策略 Z3配备了许多内置策略。 命令describe_tactics()提供了所有内置策略的简短描述。 describe_tactics() Z3Py配备了以下战术组合器（又名战术）： Then(t, s)：将t应用于输入目标，并将s应用于t产生的每个子目标。 OrElse(t, s)：首先将t应用于给定目标，如果失败，则返回s应用于给定目标的结果。 Repeat(t) ：继续应用给定的策略，直到没有子目标被修改。 Repeat(t, n)：继续应用给定的策略，直到没有子目标被修改，或者迭代次数大于n。 TryFor(t, ms)：将策略t应用于输入目标，如果它没有以ms millisenconds的形式返回，则它将失败。 With(t, params)：使用给定的参数应用给定的策略。 下面的示例演示如何使用这些组合器。 # 示例46 from z3 import * if __name__ == \"__main__\": x, y, z = Reals('x y z') g = Goal() g.add(Or(x == 0, x == 1), Or(y == 0, y == 1), Or(z == 0, z == 1), x + y + z > 2) # Split all clauses # 拆分所有子句 split_all = Repeat(OrElse(Tactic('split-clause'), Tactic('skip'))) print(split_all(g)) # [[x == 0, y == 0, z == 0, x + y + z > 2], # [x == 0, y == 0, z == 1, x + y + z > 2], # [x == 0, y == 1, z == 0, x + y + z > 2], # [x == 0, y == 1, z == 1, x + y + z > 2], # [x == 1, y == 0, z == 0, x + y + z > 2], # [x == 1, y == 0, z == 1, x + y + z > 2], # [x == 1, y == 1, z == 0, x + y + z > 2], # [x == 1, y == 1, z == 1, x + y + z > 2]] print() split_at_most_2 = Repeat(OrElse(Tactic('split-clause'), Tactic('skip')), 1) print(split_at_most_2(g)) # [[x == 0, y == 0, Or(z == 0, z == 1), x + y + z > 2], # [x == 0, y == 1, Or(z == 0, z == 1), x + y + z > 2], # [x == 1, y == 0, Or(z == 0, z == 1), x + y + z > 2], # [x == 1, y == 1, Or(z == 0, z == 1), x + y + z > 2]] print() # Split all clauses and solve equations # 拆分所有子句并求解方程式 split_solve = Then(Repeat(OrElse(Tactic('split-clause'), Tactic('skip'))),Tactic('solve-eqs')) print(split_solve(g)) # [[]] 在策略split_solver中，策略solve-eqs释放了除一个目标以外的所有目标。 请注意，此策略会产生一个目标：可以轻松满足（即可行）的空目标。 可以使用Python for语句轻松遍历子目标列表。 # 示例47 from z3 import * if __name__ == \"__main__\": x, y, z = Reals('x y z') g = Goal() g.add(Or(x == 0, x == 1), Or(y == 0, y == 1), Or(z == 0, z == 1), x + y + z > 2) # Split all clauses\" split_all = Repeat(OrElse(Tactic('split-clause'), Tactic('skip'))) for s in split_all(g): print(s) 可以使用Solver()方法将战术转换为求解器对象。 如果该策略产生了空目标，则关联的求解器将返回sat。 如果该策略产生包含False的单个目标，则求解器将返回unsat。 否则，返回未知。 # 示例48 from z3 import * if __name__ == \"__main__\": bv_solver = Then('simplify', 'solve-eqs', 'bit-blast', 'sat').solver() x, y = BitVecs('x y', 16) solve_using(bv_solver, x | y == 13, x > y) # [y = 0, x = 13] 在上面的示例中，策略bv_solver使用方程式求解，位爆破和命题SAT求解器来实现基本的位向量求解器。 注意，命令“战术”被禁止。 如果参数是字符串，则所有Z3Py组合器都会自动调用Tactic命令。 最后，命令solve_using是solve命令的变体，其中第一个参数指定要使用的求解器。 在以下示例中，我们直接使用求解器API而不是命令resolve_using。 我们使用组合器With来配置我们的小解算器。 我们还包括战术aig，它尝试使用“与逆图”压缩布尔公式。 # 示例49 from z3 import * if __name__ == \"__main__\": bv_solver = Then(With('simplify', mul2concat=True), 'solve-eqs', 'bit-blast', 'aig', 'sat').solver() x, y = BitVecs('x y', 16) bv_solver.add(x * 32 + y == 13, x & y -100) print(bv_solver.check()) # sat m = bv_solver.model() print(m) # [y = 10509, x = 1720] print(x * 32 + y, \"==\", m.evaluate(x * 32 + y)) # x*32 + y == 13 print(x & y, \"==\", m.evaluate(x & y)) # x & y == 8 策略smt将主要求解器包装在Z3中作为策略。 # 示例50 from z3 import * if __name__ == \"__main__\": x, y = Ints('x y') s = Tactic('smt').solver() s.add(x > y + 1) print(s.check()) # sat print(s.model()) # [y = -2, x = 0] 现在，我们展示如何使用SAT实现整数算法的求解器。 仅对于每个变量都有上限和下限的问题，求解器才是完整的。 # 示例51 from z3 import * if __name__ == \"__main__\": s = Then(With('simplify', arith_lhs=True, som=True), 'normalize-bounds', 'lia2pb', 'pb2bv', 'bit-blast', 'sat').solver() x, y, z = Ints('x y z') solve_using(s, x > 0, x 0, y 0, z 策略可以与求解器结合使用。 例如，我们可以将策略应用于目标，生成一组子目标，然后选择一个子目标并使用求解器对其进行求解。 下一个示例演示了如何执行此操作，以及如何使用模型转换器将子目标的模型转换为原始目标的模型。 # 示例52 from z3 import * if __name__ == \"__main__\": t = Then('simplify','normalize-bounds','solve-eqs') x, y, z = Ints('x y z') g = Goal() g.add(x > 10, y == x + 3, z > y) r = t(g) # r contains only one subgoal # r仅包含一个子目标 print(r) # [[Not(k!0 AttributeError: 'ApplyResult' object has no attribute 'convert_model' # print(r.convert_model(s.model())) 3、探针 探测（又称公式测度）是针对目标进行评估的。 可以使用关系运算符和布尔连接词来构建它们之上的布尔表达式。 如果给定目标不满足条件cond，则战术FailIf（cond）失败。 Z3Py中提供了许多数值和布尔量度。 命令describe_probes（）提供所有内置探针的列表。 describe_probes() 在下面的示例中，我们使用FailIf构建简单的策略。 它还表明可以将探针直接应用于目标。 # 示例53 from z3 import * if __name__ == \"__main__\": x, y, z = Reals('x y z') g = Goal() g.add(x + y + z > 0) p = Probe('num-consts') print(\"num-consts:\", p(g)) # num-consts: 3.0 t = FailIf(p > 2) try: t(g) except Z3Exception: print(\"tactic failed\") # tactic failed print(\"trying again...\") # trying again... g = Goal() g.add(x + y > 0) print(t(g)) # [[x + y > 0]] Z3Py还提供了组合器（战术） If(p, t1, t2)，它是以下各项的简写： OrElse(Then(FailIf(Not(p)), t1), t2) 组合器 When(p, t)是以下各项的简写： If(p, t, 'skip') skip策略只是返回输入目标。 下面的示例演示如何使用If组合器。 # 示例54 from z3 import * if __name__ == \"__main__\": x, y, z = Reals('x y z') g = Goal() g.add(x ** 2 - y ** 2 >= 0) p = Probe('num-consts') t = If(p > 2, 'simplify', 'factor') print(t(g)) # [[(y + -1*x)*(y + x) = 0, x ** 2 - y ** 2 >= 0) print(t(g)) # [[2*x + y + z >= 0, x**2 + -1*y**2 >= 0]] Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/应用/推理.html":{"url":"docs/应用/推理.html","title":"应用","keywords":"","body":"1、推理-应用1 # 源地址: https://www.7forz.com/3255/ # 一军用仓库被窃，公安部门已掌握如下线索： # ①甲、乙、丙三人至少有一个是窃贼； # ②如甲是窃贼，则乙一定是同案犯； # ③盗窃发生时，乙正在影剧院看电影。由此可以推出（ ）。 # A.甲、乙、丙都是窃贼 # B.甲和乙都是窃贼 # C.丙是窃贼 # D.甲是窃贼 # 运行代码后，第3条的结果为 unsat，即对应原选项 C 是正确的。 # a,b,c => 甲乙丙三人， true为盗贼 from z3 import * a = Bool('a') # 若甲是窃贼 则a为真 b = Bool('b') c = Bool('c') def build_solver(): solver = Solver() # 给solver添加约束条件 solver.add(If(a, 1, 0) + If(b, 1, 0) + If(c, 1, 0) >= 1) # 条件1：三人至少有一个是窃贼 solver.add(Implies(a, b)) # 条件2：如甲是窃贼 则乙一定是同案犯 solver.add(Not(b)) # 条件3：乙一定不是 return solver if __name__ == \"__main__\": solver = build_solver() # 采用反证法 把各选项的 *否定* 添加进solver中 若冲突将返回unsat 原选项正确 solver.add(Not(And(a, b, c))) # 甲、乙、丙都是窃贼 print(solver.check()) # will output \"sat\" solver = build_solver() solver.add(Not(And(a, b))) # 甲和乙都是窃贼 print(solver.check()) # will output \"sat\" solver = build_solver() solver.add(Not(c)) # 丙是窃贼 print(solver.check()) # will output \"unsat\" solver = build_solver() solver.add(Not(a)) # 甲是窃贼 print(solver.check()) # will output \"sat\" 2、推理 # 源地址: https://www.7forz.com/3255/ # 某大型煤矿发生了一起重大事故，事发现场的人有以下的断定： # # 矿工甲：发生事故的原因是设备问题； # 矿工乙：有人违反了操作规程，但发生事故的原因不是设备问题； # 矿工丙：如果发生事故的原因是设备问题，那么有人违反操作规程； # 矿工丁：发生事故的原因是设备问题，但没有人违反操作规程。 # # 如果上述四人的断定中只有一个人为真，则以下可能为真的一项是（ ）。 # # A.矿工甲的断定为真 # B.矿工乙的断定为真 # C.矿工丁的断定为真 # D.矿工丙的断定为真，有人违反了操作规程 # E.矿工丙的断定为真，没有人违反操作规程 # 由运行结果可见选项 E 是正确的。 # 应用2 from z3 import * equipment = Bool('shebei') # 设备是否有问题 violation = Bool('weifan') # 是否违反操作规程 s1 = equipment # 甲：发生事故的原因是设备问题 s2 = And(violation, Not(equipment)) # 乙：违反了操作规程，但不是设备问题 s3 = Implies(equipment, violation) # 丙：如果事故的原因是设备问题，那么违反操作规程 s4 = And(equipment, Not(violation)) # 丁：发生事故的原因是设备问题，但没有人违反操作规程 def build_solver(): solver = Solver() solver.add(If(s1, 1, 0) + If(s2, 1, 0) + If(s3, 1, 0) + If(s4, 1, 0) == 1) # 四人的断定中只有一个人为真 return solver if __name__ == '__main__': solver = build_solver() # 采用反证法 把各选项的 *否定* 添加进solver中 若冲突将返回unsat 原选项正确 solver.add(Not(s1)) # 甲的断定为真 print(solver.check()) # sat solver = build_solver() solver.add(Not(s2)) # 乙的断定为真 print(solver.check()) # sat solver = build_solver() solver.add(Not(s4)) # 丁的断定为真 print(solver.check()) # sat solver = build_solver() solver.add(Not(And(s3, violation))) # 丙的断定为真 并且有人违反了操作规程 print(solver.check()) # sat solver = build_solver() solver.add(Not(And(s3, Not(violation)))) # 丙的断定为真 并且没有人违反操作规程 print(solver.check()) # unsat Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "},"docs/paper/综述.html":{"url":"docs/paper/综述.html","title":"综述","keywords":"","body":"综述 [x] 【综述】金继伟,马菲菲,张健.SMT求解技术简述[J].计算机科学与探索,2015,9(07):769-780. http://fcst.ceaj.org/CN/abstract/abstract956.shtml [x] 【综述】王翀,吕荫润,陈力,王秀利,王永吉.SMT求解技术的发展及最新应用研究综述[J].计算机研究与发展,2017,54(07):1405-1425. https://crad.ict.ac.cn/CN/10.7544/issn1000-1239.2017.20160303 Copyright © Zhi2014 2023 all right reserved，powered by Gitbook该文件修订时间： 2023-03-09 17:52:10 "}}